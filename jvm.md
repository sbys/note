第一章 走进java
第二章 java内存区域与内存溢出异常
第三章 垃圾收集器与内存分配策略
第六章 类文件结构
第七章 虚拟机类加载机制
第八章 虚拟机字节码执行引擎
第九章 类加载及执行子系统的案例与实战
第十章 早期（编译器优化）
第十一章 晚期（运行期）优化
第十二章 java内存模型与线程
第十三章 线程安全与锁优化

第一章
  java技术体系：
    java程序设计语言
    各种硬件平台上的java虚拟机
    class文件格式
    java api类库
    第三方类库
   java 程序设计语言，java虚拟机，java api类库成为jdk
   java api类库中的se子集和java虚拟机统称为jre
   java技术体系（按领域划分）
    java Card
    java Me 移动终端
    java se 支持面向桌面级应用
    java ee 支持使用多层架构的企业应用
第二章 java内存区域与内存区域异常
 2.1
  c++ delete free
  java gc
 2.2 运行时数据区域
  方法区，虚拟机栈，本地方法栈，堆，程序计数器
  2.2.1程序计数器
   是一块较小的内存空间，当前线程所执行的字节码的行号指示器，线程私有，如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节的字节码    指令的地址，如果执行的是Native方法，这个计数器值为空。此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
  2.2.2java虚拟机栈
   线程私有，生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（stack frame），用于存储局部变量      表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应这一个栈帧在虚拟机栈从入栈道出栈的过程。局部变量表存放了编译器可知    的各种基本数据类型（boolean，byte，char，short，int，float，long，double）、对象引用（referene类型）和returnAddress类型。其中64位长度的long    和double类型的数据会占用2个局部变量空间，其余的数据类型只占用一个局部变量空间。局部变量表所需的内存空间在便宜期间完成分配，当进入一个方法时，这个    方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
   在java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；如果虚拟机栈可以动态
   扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
  2.2.3本地方法栈
   本地方法栈与虚拟机栈所发挥的作用是非常相似的，执行Native方法，也会抛出StackOverflowError和OutOfMemoryErrory异常。
  2.2.4java堆
    java堆（java Heap）是java虚拟机所管理的内存中最大的一块。所有线程共享，虚拟机启动时创建，此区域的唯一目的是存放对象实例还有数组。
    java堆是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆（Garbage Collected Heap）.垃圾收集器主要是基于堆，如果在堆中没有内存完成实例分配，并     且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
   2.2.5方法区
    方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将
    OutOfMemoryError异常。
